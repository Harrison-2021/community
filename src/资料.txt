第一课时：
    1. maven 配置与操作，官网->user Centre->Maven in 5 Minutes:
        1. mvn -version，查看版本
        2. 创建项目，找到要创建对象保存的地址，
            mvn archetype:generate -DgroupId=com.nowcoder.mavendemo1 -DartifactId=mavendemo1 -DarchetypeArtifactId=maven-archetype-quickstart -DarchetypeVersion=1.4 -DinteractiveMode=false
        3. 项目编译，找到目标文件下，mvn compile
        4. 重新编译，mvn clean compile
        5. 测试，mvn clean test
   2. Spring Boot 核心作用
        1. 起步依赖、自动配置、端点监控

   3. tomcat服务器，可以更改端口，在application.properties配置文件中修改
        server.port=8080
        server.servlet.context-path=/community

   4. IOC容器设计：用容器管理bean，bean相当于类的代理，减少对象之间的耦合度
        1. 前提：管理哪些bean，以及benn的类型，
            配置文件进行配置，通过配置描述进行关联，不是对象之间直接关联
        2. 运行原理： SpringApplication，运行时，不仅自动启动tomcate，还自动创建了Spring容器，容器会自动扫描包，配置信息，
        3. 注解的种类:1是使用bean，@Autowired,@
            2是注册bean,@Component,@Repository,@Controller,@Service, @Configuration这些注解都是把你要实例化的对象转化成一个Bean，放在IoC容器中，等你要用的时候，它会和上面的@Autowired , @Resource配合到一起，把对象、属性、方法完美组装。
        4. 在测试类中演示IOC运行机制
            首先，在测试类中添加注解配置，@ContextConfiguration(classes = CommunityApplication.class)
            类要实现ApplicationContextAware接口，并重写set方法
	        书写操作数据库的文件AlphaDaoHibernateImpl，从AlphaDAO继承，加上注解@Repository，会将类加到容器里
	        在测试类中，用容器拿到bean，再将拿到的bean打印出来进行测试
	    5. 为了体现IOC运行的优势，再创建一个操作数据库文件AlphaDaoMybatisImpl，同样继承
	        为了作出区分，多加一个注解@Primary,就会优先调用，因此，定义好接口，只需修改配置注解，就可以降低对象之间的耦合度
	    6. 可以在注解中，加上bean的名字，这样，可以直接通过名字获取bean
	    7. IOC容器还可以管理bean的初始化和销毁
	        增加一个Service对象，在初始化方法上注解@PostConstruct，
	        在销毁方法前加注解@PreDestroy
	    8. 用IOC管理其他包的类，
	        建立一个配置类，在配置类中进行依赖管理，config->AlphaConfig->@Configuration
            在目标方法前，加入注解@Bean，将方法返回的对象装到容器里，SimpleDateFormat
        9. Spring Boot框架中自动获取Bean方法，
            @Autowired，在类属性前注入，获取目标Bean，默认是@Primary注解的Bean
            @Qualifier,写上Bean的名字，可以自动装配改名字的Bean
        10. 项目中调用流程：Controller调用Service，Service调用DAO，都是用依赖注入的方式调用
   5. Spring MVC，注意三层架构和MVC不是一回事
        1. DispatcherServlet是整个SpringMVC的核心
            首先，浏览器的请求都由FrontController前端控制器中的DispatcherServlet类来控制，
            DispatcherServlet根据映射的注解找到Controller，将请求下发，
                然后Controller会把数据封装到model里将回复返回给前端控制器
            前端控制器得到回复后，会调用View template，并将model给模板，template中的动态符号会用model中动态值替换，生成动态网页
                View中生成一个html后返回前端控制器，控制器将html响应给浏览器
        2. 模板引擎用的是Thymeleaf，在配置文件中进行配置
            1.将默认的缓存关掉，可以实时更新页面，上线时候可以再开启，降低服务器压力
                spring.thymeleaf.cache=false
            2. 接收请求和响应的底层实现，request，response
            3. 框架中简单的操作，请求数据的处理，框架已经将底层操作包装好了
                1. get请求，/students?current=1&limit=20，
                    @RequestMapping(path="",method=RequestMethod.GET),先解析相对路径，和请求方法
                    方法中传入参数， 加入注解@RequestParam，required，是否一定要写入参数，defaultValue，默认值
                2. get请求中，将参数当成路径的一部分，即/student/123
                    @RequestMapping(path = "/student/{id}", method = RequestMethod.GET)
                    @PathVariable("id") int id
                3. post请求，get请求是在路径上传的，传输的东西较多，且内容不能被显示出来时，用post
                    1. 创建一个静态网页，新建一个html的表单，
                        表单中注明请求方法，请求的url相对地址，注意是相对于根目录
                        创建两个输入框，一个保存按钮，注意类型，名称
                    2. 在Controller层书写获取post的请求，传入的参数只要和表单一致，就可以获取请求，可以直接写不用写注解
            4. 框架中响应数据的处理
                1.  响应html动态数据，不加ResponseBody，返回类型是ModelAndView，将model与view的数据都装进一个对象里
                    1. 先实例化对象 modelAndView，
                    2. 将动态的要响应的值传入，addObject
                    3. 跳转到动态资源文件，即模板，进行渲染，setVieName，传入目标模板路径的文件名
                        1，先将模板进行声明，注明是动态模板，xmlns:th="http://www.thymeleaf.org"
                        2. 用th:text="${name}"获取变量
	            2. 第二种响应方式，用model对象。自动实例话model对象，直接装数据
	                    1. addAttribute
	            3. 区别：ModelAndView，将model与view的数据都装进一个对象里
	                     model，将model作为参数传入，自动创建model实例，在model种装入数据，返回的视图view直接作为返回给控制器DispatcherServlet
                4. 响应JSON数据，异步请求，当前网页不动，悄悄的访问服务器一次
                    响应JSON数据(异步请求)
                    Java对象 -> JSON字符串 -> JS对象
                    @ResponseBody如果想返回js对象，必须加这个
                        定义一个map存储数据，DispatcherSer识别后，会自动将map转成一个js字符串返回给浏览器
                        也可以定义一个List集合，集合内装map